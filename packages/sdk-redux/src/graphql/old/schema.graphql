# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

interface Event {
    id: ID!
    transaction: Transaction!
}

type Account {
    accountWithToken(first: Int = 100, orderBy: AccountWithToken_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: AccountWithToken_filter): [AccountWithToken!]!
    downgradeEvents(first: Int = 100, orderBy: TokenDowngraded_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenDowngraded_filter): [TokenDowngraded!]!
    flowsOwned(first: Int = 100, orderBy: Flow_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Flow_filter): [Flow!]!
    flowsReceived(first: Int = 100, orderBy: Flow_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Flow_filter): [Flow!]!
    id: ID!
    upgradeEvents(first: Int = 100, orderBy: TokenUpgraded_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenUpgraded_filter): [TokenUpgraded!]!
}

type AccountWithToken {
    account: Account!
    balance: BigDecimal!
    id: ID!
    token: Token!
    transferEventsReceived(first: Int = 100, orderBy: TokenTransfer_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenTransfer_filter): [TokenTransfer!]!
    transferEventsSent(first: Int = 100, orderBy: TokenTransfer_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenTransfer_filter): [TokenTransfer!]!
}

type Flow {
    events(first: Int = 100, orderBy: FlowUpdated_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: FlowUpdated_filter): [FlowUpdated!]!
    flowRate: BigInt!
    id: ID!
    lastUpdate: BigInt!
    owner: Account!
    recipient: Account!
    sum: BigDecimal!
    token: Token!
}

type FlowUpdated implements Event {
    flow: Flow!
    flowRate: BigInt!
    id: ID!
    oldFlowRate: BigInt!
    sum: BigDecimal!
    transaction: Transaction!
}

type Index {
    id: ID!
    indexId: BigInt
    indexSubscribed(first: Int = 100, orderBy: indexSubscribed_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: indexSubscribed_filter): [indexSubscribed!]!
    indexUnitUpdate(first: Int = 100, orderBy: indexUnitUpdate_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: indexUnitUpdate_filter): [indexUnitUpdate!]!
    indexUnsubscribed(first: Int = 100, orderBy: indexUnsubscribed_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: indexUnsubscribed_filter): [indexUnsubscribed!]!
    indexUpdate(first: Int = 100, orderBy: indexUpdate_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: indexUpdate_filter): [indexUpdate!]!
    newIndexValue: BigInt
    oldIndexValue: BigInt
    publisher: Bytes
    subscribers(first: Int = 100, orderBy: Subscriber_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Subscriber_filter): [Subscriber!]!
    token: Bytes
    totalDistribution: BigInt
    totalUnits: BigInt
    totalUnitsApproved: BigInt
    totalUnitsPending: BigInt
    userData: Bytes
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    account(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): Account
    accountWithToken(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): AccountWithToken
    accountWithTokens(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AccountWithToken_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: AccountWithToken_filter
    ): [AccountWithToken!]!
    accounts(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Account_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Account_filter
    ): [Account!]!
    event(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): Event
    events(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Event_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Event_filter
    ): [Event!]!
    flow(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): Flow
    flowUpdated(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): FlowUpdated
    flowUpdateds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FlowUpdated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: FlowUpdated_filter
    ): [FlowUpdated!]!
    flows(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Flow_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Flow_filter
    ): [Flow!]!
    index(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): Index
    indexSubscribed(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): indexSubscribed
    indexSubscribeds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: indexSubscribed_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: indexSubscribed_filter
    ): [indexSubscribed!]!
    indexUnitUpdate(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): indexUnitUpdate
    indexUnitUpdates(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: indexUnitUpdate_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: indexUnitUpdate_filter
    ): [indexUnitUpdate!]!
    indexUnsubscribed(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): indexUnsubscribed
    indexUnsubscribeds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: indexUnsubscribed_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: indexUnsubscribed_filter
    ): [indexUnsubscribed!]!
    indexUpdate(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): indexUpdate
    indexUpdates(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: indexUpdate_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: indexUpdate_filter
    ): [indexUpdate!]!
    indexes(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Index_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Index_filter
    ): [Index!]!
    subscriber(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): Subscriber
    subscribers(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Subscriber_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Subscriber_filter
    ): [Subscriber!]!
    subscriptionApproved(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): subscriptionApproved
    subscriptionApproveds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: subscriptionApproved_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: subscriptionApproved_filter
    ): [subscriptionApproved!]!
    subscriptionRevoked(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): subscriptionRevoked
    subscriptionRevokeds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: subscriptionRevoked_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: subscriptionRevoked_filter
    ): [subscriptionRevoked!]!
    subscriptionUnitsUpdated(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): subscriptionUnitsUpdated
    subscriptionUnitsUpdateds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: subscriptionUnitsUpdated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: subscriptionUnitsUpdated_filter
    ): [subscriptionUnitsUpdated!]!
    superTokenCreated(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): SuperTokenCreated
    superTokenCreateds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SuperTokenCreated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: SuperTokenCreated_filter
    ): [SuperTokenCreated!]!
    token(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): Token
    tokenDowngraded(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): TokenDowngraded
    tokenDowngradeds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenDowngraded_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: TokenDowngraded_filter
    ): [TokenDowngraded!]!
    tokenTransfer(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): TokenTransfer
    tokenTransfers(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenTransfer_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: TokenTransfer_filter
    ): [TokenTransfer!]!
    tokenUpgraded(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): TokenUpgraded
    tokenUpgradeds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenUpgraded_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: TokenUpgraded_filter
    ): [TokenUpgraded!]!
    tokens(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Token_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Token_filter
    ): [Token!]!
    transaction(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): Transaction
    transactions(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Transaction_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Transaction_filter
    ): [Transaction!]!
}

type Subscriber {
    approved: Boolean
    id: ID!
    index: Index
    indexId: BigInt
    publisher: Bytes
    subscriber: Bytes
    subscriptionApproved(first: Int = 100, orderBy: subscriptionApproved_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: subscriptionApproved_filter): [subscriptionApproved!]!
    subscriptionRevoked(first: Int = 100, orderBy: subscriptionRevoked_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: subscriptionRevoked_filter): [subscriptionRevoked!]!
    subscriptionUnitsUpdated(first: Int = 100, orderBy: subscriptionUnitsUpdated_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: subscriptionUnitsUpdated_filter): [subscriptionUnitsUpdated!]!
    token: Bytes
    totalPendingApproval: BigInt
    totalReceived: BigInt
    units: BigInt
    userData: Bytes
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    account(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): Account
    accountWithToken(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): AccountWithToken
    accountWithTokens(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AccountWithToken_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: AccountWithToken_filter
    ): [AccountWithToken!]!
    accounts(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Account_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Account_filter
    ): [Account!]!
    event(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): Event
    events(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Event_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Event_filter
    ): [Event!]!
    flow(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): Flow
    flowUpdated(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): FlowUpdated
    flowUpdateds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FlowUpdated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: FlowUpdated_filter
    ): [FlowUpdated!]!
    flows(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Flow_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Flow_filter
    ): [Flow!]!
    index(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): Index
    indexSubscribed(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): indexSubscribed
    indexSubscribeds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: indexSubscribed_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: indexSubscribed_filter
    ): [indexSubscribed!]!
    indexUnitUpdate(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): indexUnitUpdate
    indexUnitUpdates(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: indexUnitUpdate_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: indexUnitUpdate_filter
    ): [indexUnitUpdate!]!
    indexUnsubscribed(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): indexUnsubscribed
    indexUnsubscribeds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: indexUnsubscribed_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: indexUnsubscribed_filter
    ): [indexUnsubscribed!]!
    indexUpdate(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): indexUpdate
    indexUpdates(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: indexUpdate_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: indexUpdate_filter
    ): [indexUpdate!]!
    indexes(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Index_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Index_filter
    ): [Index!]!
    subscriber(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): Subscriber
    subscribers(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Subscriber_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Subscriber_filter
    ): [Subscriber!]!
    subscriptionApproved(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): subscriptionApproved
    subscriptionApproveds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: subscriptionApproved_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: subscriptionApproved_filter
    ): [subscriptionApproved!]!
    subscriptionRevoked(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): subscriptionRevoked
    subscriptionRevokeds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: subscriptionRevoked_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: subscriptionRevoked_filter
    ): [subscriptionRevoked!]!
    subscriptionUnitsUpdated(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): subscriptionUnitsUpdated
    subscriptionUnitsUpdateds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: subscriptionUnitsUpdated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: subscriptionUnitsUpdated_filter
    ): [subscriptionUnitsUpdated!]!
    superTokenCreated(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): SuperTokenCreated
    superTokenCreateds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SuperTokenCreated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: SuperTokenCreated_filter
    ): [SuperTokenCreated!]!
    token(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): Token
    tokenDowngraded(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): TokenDowngraded
    tokenDowngradeds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenDowngraded_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: TokenDowngraded_filter
    ): [TokenDowngraded!]!
    tokenTransfer(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): TokenTransfer
    tokenTransfers(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenTransfer_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: TokenTransfer_filter
    ): [TokenTransfer!]!
    tokenUpgraded(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): TokenUpgraded
    tokenUpgradeds(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenUpgraded_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: TokenUpgraded_filter
    ): [TokenUpgraded!]!
    tokens(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Token_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Token_filter
    ): [Token!]!
    transaction(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!
    ): Transaction
    transactions(
        "The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Transaction_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Transaction_filter
    ): [Transaction!]!
}

type SuperTokenCreated implements Event {
    address: Bytes!
    id: ID!
    name: String!
    symbol: String!
    transaction: Transaction!
    underlyingAddress: Bytes!
}

type Token {
    accountWithToken(first: Int = 100, orderBy: AccountWithToken_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: AccountWithToken_filter): [AccountWithToken!]!
    downgradeEvents(first: Int = 100, orderBy: TokenDowngraded_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenDowngraded_filter): [TokenDowngraded!]!
    flows(first: Int = 100, orderBy: Flow_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Flow_filter): [Flow!]!
    id: ID!
    name: String!
    symbol: String!
    underlyingAddress: Bytes!
    upgradeEvents(first: Int = 100, orderBy: TokenUpgraded_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenUpgraded_filter): [TokenUpgraded!]!
}

type TokenDowngraded implements Event {
    account: Account!
    amount: BigInt!
    id: ID!
    token: Token!
    transaction: Transaction!
}

type TokenTransfer implements Event {
    from: AccountWithToken!
    id: ID!
    to: AccountWithToken!
    token: Token!
    transaction: Transaction!
    value: BigInt!
}

type TokenUpgraded implements Event {
    account: Account!
    amount: BigInt!
    id: ID!
    token: Token!
    transaction: Transaction!
}

type Transaction {
    blockNumber: BigInt!
    events(first: Int = 100, orderBy: Event_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Event_filter): [Event!]!
    id: ID!
    timestamp: BigInt!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

type indexSubscribed implements Event {
    id: ID!
    index: Index
    subscriber: Bytes
    transaction: Transaction!
    userData: Bytes
}

type indexUnitUpdate implements Event {
    id: ID!
    index: Index
    subscriber: Bytes
    transaction: Transaction!
    units: BigInt
    userData: Bytes
}

type indexUnsubscribed implements Event {
    id: ID!
    index: Index
    subscriber: Bytes
    transaction: Transaction!
    userData: Bytes
}

type indexUpdate implements Event {
    distribution: BigInt
    id: ID!
    index: Index
    newIndexValue: BigInt
    oldIndexValue: BigInt
    totalUnitsApproved: BigInt
    totalUnitsPending: BigInt
    transaction: Transaction!
    userData: Bytes
}

type subscriptionApproved implements Event {
    id: ID!
    subscriber: Subscriber
    transaction: Transaction!
    userData: Bytes
}

type subscriptionRevoked implements Event {
    id: ID!
    subscriber: Subscriber
    transaction: Transaction!
    userData: Bytes
}

type subscriptionUnitsUpdated implements Event {
    id: ID!
    subscriber: Subscriber
    transaction: Transaction!
    units: BigInt
    userData: Bytes
}

enum AccountWithToken_orderBy {
    account
    balance
    id
    token
    transferEventsReceived
    transferEventsSent
}

enum Account_orderBy {
    accountWithToken
    downgradeEvents
    flowsOwned
    flowsReceived
    id
    upgradeEvents
}

enum Event_orderBy {
    id
    transaction
}

enum FlowUpdated_orderBy {
    flow
    flowRate
    id
    oldFlowRate
    sum
    transaction
}

enum Flow_orderBy {
    events
    flowRate
    id
    lastUpdate
    owner
    recipient
    sum
    token
}

enum Index_orderBy {
    id
    indexId
    indexSubscribed
    indexUnitUpdate
    indexUnsubscribed
    indexUpdate
    newIndexValue
    oldIndexValue
    publisher
    subscribers
    token
    totalDistribution
    totalUnits
    totalUnitsApproved
    totalUnitsPending
    userData
}

enum OrderDirection {
    asc
    desc
}

enum Subscriber_orderBy {
    approved
    id
    index
    indexId
    publisher
    subscriber
    subscriptionApproved
    subscriptionRevoked
    subscriptionUnitsUpdated
    token
    totalPendingApproval
    totalReceived
    units
    userData
}

enum SuperTokenCreated_orderBy {
    address
    id
    name
    symbol
    transaction
    underlyingAddress
}

enum TokenDowngraded_orderBy {
    account
    amount
    id
    token
    transaction
}

enum TokenTransfer_orderBy {
    from
    id
    to
    token
    transaction
    value
}

enum TokenUpgraded_orderBy {
    account
    amount
    id
    token
    transaction
}

enum Token_orderBy {
    accountWithToken
    downgradeEvents
    flows
    id
    name
    symbol
    underlyingAddress
    upgradeEvents
}

enum Transaction_orderBy {
    blockNumber
    events
    id
    timestamp
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

enum indexSubscribed_orderBy {
    id
    index
    subscriber
    transaction
    userData
}

enum indexUnitUpdate_orderBy {
    id
    index
    subscriber
    transaction
    units
    userData
}

enum indexUnsubscribed_orderBy {
    id
    index
    subscriber
    transaction
    userData
}

enum indexUpdate_orderBy {
    distribution
    id
    index
    newIndexValue
    oldIndexValue
    totalUnitsApproved
    totalUnitsPending
    transaction
    userData
}

enum subscriptionApproved_orderBy {
    id
    subscriber
    transaction
    userData
}

enum subscriptionRevoked_orderBy {
    id
    subscriber
    transaction
    userData
}

enum subscriptionUnitsUpdated_orderBy {
    id
    subscriber
    transaction
    units
    userData
}

input AccountWithToken_filter {
    account: String
    account_contains: String
    account_ends_with: String
    account_gt: String
    account_gte: String
    account_in: [String!]
    account_lt: String
    account_lte: String
    account_not: String
    account_not_contains: String
    account_not_ends_with: String
    account_not_in: [String!]
    account_not_starts_with: String
    account_starts_with: String
    balance: BigDecimal
    balance_gt: BigDecimal
    balance_gte: BigDecimal
    balance_in: [BigDecimal!]
    balance_lt: BigDecimal
    balance_lte: BigDecimal
    balance_not: BigDecimal
    balance_not_in: [BigDecimal!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    token: String
    token_contains: String
    token_ends_with: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_ends_with: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_starts_with: String
}

input Account_filter {
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
}

input Block_height {
    hash: Bytes
    number: Int
}

input Event_filter {
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    transaction: String
    transaction_contains: String
    transaction_ends_with: String
    transaction_gt: String
    transaction_gte: String
    transaction_in: [String!]
    transaction_lt: String
    transaction_lte: String
    transaction_not: String
    transaction_not_contains: String
    transaction_not_ends_with: String
    transaction_not_in: [String!]
    transaction_not_starts_with: String
    transaction_starts_with: String
}

input FlowUpdated_filter {
    flow: String
    flowRate: BigInt
    flowRate_gt: BigInt
    flowRate_gte: BigInt
    flowRate_in: [BigInt!]
    flowRate_lt: BigInt
    flowRate_lte: BigInt
    flowRate_not: BigInt
    flowRate_not_in: [BigInt!]
    flow_contains: String
    flow_ends_with: String
    flow_gt: String
    flow_gte: String
    flow_in: [String!]
    flow_lt: String
    flow_lte: String
    flow_not: String
    flow_not_contains: String
    flow_not_ends_with: String
    flow_not_in: [String!]
    flow_not_starts_with: String
    flow_starts_with: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    oldFlowRate: BigInt
    oldFlowRate_gt: BigInt
    oldFlowRate_gte: BigInt
    oldFlowRate_in: [BigInt!]
    oldFlowRate_lt: BigInt
    oldFlowRate_lte: BigInt
    oldFlowRate_not: BigInt
    oldFlowRate_not_in: [BigInt!]
    sum: BigDecimal
    sum_gt: BigDecimal
    sum_gte: BigDecimal
    sum_in: [BigDecimal!]
    sum_lt: BigDecimal
    sum_lte: BigDecimal
    sum_not: BigDecimal
    sum_not_in: [BigDecimal!]
    transaction: String
    transaction_contains: String
    transaction_ends_with: String
    transaction_gt: String
    transaction_gte: String
    transaction_in: [String!]
    transaction_lt: String
    transaction_lte: String
    transaction_not: String
    transaction_not_contains: String
    transaction_not_ends_with: String
    transaction_not_in: [String!]
    transaction_not_starts_with: String
    transaction_starts_with: String
}

input Flow_filter {
    flowRate: BigInt
    flowRate_gt: BigInt
    flowRate_gte: BigInt
    flowRate_in: [BigInt!]
    flowRate_lt: BigInt
    flowRate_lte: BigInt
    flowRate_not: BigInt
    flowRate_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    lastUpdate: BigInt
    lastUpdate_gt: BigInt
    lastUpdate_gte: BigInt
    lastUpdate_in: [BigInt!]
    lastUpdate_lt: BigInt
    lastUpdate_lte: BigInt
    lastUpdate_not: BigInt
    lastUpdate_not_in: [BigInt!]
    owner: String
    owner_contains: String
    owner_ends_with: String
    owner_gt: String
    owner_gte: String
    owner_in: [String!]
    owner_lt: String
    owner_lte: String
    owner_not: String
    owner_not_contains: String
    owner_not_ends_with: String
    owner_not_in: [String!]
    owner_not_starts_with: String
    owner_starts_with: String
    recipient: String
    recipient_contains: String
    recipient_ends_with: String
    recipient_gt: String
    recipient_gte: String
    recipient_in: [String!]
    recipient_lt: String
    recipient_lte: String
    recipient_not: String
    recipient_not_contains: String
    recipient_not_ends_with: String
    recipient_not_in: [String!]
    recipient_not_starts_with: String
    recipient_starts_with: String
    sum: BigDecimal
    sum_gt: BigDecimal
    sum_gte: BigDecimal
    sum_in: [BigDecimal!]
    sum_lt: BigDecimal
    sum_lte: BigDecimal
    sum_not: BigDecimal
    sum_not_in: [BigDecimal!]
    token: String
    token_contains: String
    token_ends_with: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_ends_with: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_starts_with: String
}

input Index_filter {
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    indexId: BigInt
    indexId_gt: BigInt
    indexId_gte: BigInt
    indexId_in: [BigInt!]
    indexId_lt: BigInt
    indexId_lte: BigInt
    indexId_not: BigInt
    indexId_not_in: [BigInt!]
    newIndexValue: BigInt
    newIndexValue_gt: BigInt
    newIndexValue_gte: BigInt
    newIndexValue_in: [BigInt!]
    newIndexValue_lt: BigInt
    newIndexValue_lte: BigInt
    newIndexValue_not: BigInt
    newIndexValue_not_in: [BigInt!]
    oldIndexValue: BigInt
    oldIndexValue_gt: BigInt
    oldIndexValue_gte: BigInt
    oldIndexValue_in: [BigInt!]
    oldIndexValue_lt: BigInt
    oldIndexValue_lte: BigInt
    oldIndexValue_not: BigInt
    oldIndexValue_not_in: [BigInt!]
    publisher: Bytes
    publisher_contains: Bytes
    publisher_in: [Bytes!]
    publisher_not: Bytes
    publisher_not_contains: Bytes
    publisher_not_in: [Bytes!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    totalDistribution: BigInt
    totalDistribution_gt: BigInt
    totalDistribution_gte: BigInt
    totalDistribution_in: [BigInt!]
    totalDistribution_lt: BigInt
    totalDistribution_lte: BigInt
    totalDistribution_not: BigInt
    totalDistribution_not_in: [BigInt!]
    totalUnits: BigInt
    totalUnitsApproved: BigInt
    totalUnitsApproved_gt: BigInt
    totalUnitsApproved_gte: BigInt
    totalUnitsApproved_in: [BigInt!]
    totalUnitsApproved_lt: BigInt
    totalUnitsApproved_lte: BigInt
    totalUnitsApproved_not: BigInt
    totalUnitsApproved_not_in: [BigInt!]
    totalUnitsPending: BigInt
    totalUnitsPending_gt: BigInt
    totalUnitsPending_gte: BigInt
    totalUnitsPending_in: [BigInt!]
    totalUnitsPending_lt: BigInt
    totalUnitsPending_lte: BigInt
    totalUnitsPending_not: BigInt
    totalUnitsPending_not_in: [BigInt!]
    totalUnits_gt: BigInt
    totalUnits_gte: BigInt
    totalUnits_in: [BigInt!]
    totalUnits_lt: BigInt
    totalUnits_lte: BigInt
    totalUnits_not: BigInt
    totalUnits_not_in: [BigInt!]
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input Subscriber_filter {
    approved: Boolean
    approved_in: [Boolean!]
    approved_not: Boolean
    approved_not_in: [Boolean!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    index: String
    indexId: BigInt
    indexId_gt: BigInt
    indexId_gte: BigInt
    indexId_in: [BigInt!]
    indexId_lt: BigInt
    indexId_lte: BigInt
    indexId_not: BigInt
    indexId_not_in: [BigInt!]
    index_contains: String
    index_ends_with: String
    index_gt: String
    index_gte: String
    index_in: [String!]
    index_lt: String
    index_lte: String
    index_not: String
    index_not_contains: String
    index_not_ends_with: String
    index_not_in: [String!]
    index_not_starts_with: String
    index_starts_with: String
    publisher: Bytes
    publisher_contains: Bytes
    publisher_in: [Bytes!]
    publisher_not: Bytes
    publisher_not_contains: Bytes
    publisher_not_in: [Bytes!]
    subscriber: Bytes
    subscriber_contains: Bytes
    subscriber_in: [Bytes!]
    subscriber_not: Bytes
    subscriber_not_contains: Bytes
    subscriber_not_in: [Bytes!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    totalPendingApproval: BigInt
    totalPendingApproval_gt: BigInt
    totalPendingApproval_gte: BigInt
    totalPendingApproval_in: [BigInt!]
    totalPendingApproval_lt: BigInt
    totalPendingApproval_lte: BigInt
    totalPendingApproval_not: BigInt
    totalPendingApproval_not_in: [BigInt!]
    totalReceived: BigInt
    totalReceived_gt: BigInt
    totalReceived_gte: BigInt
    totalReceived_in: [BigInt!]
    totalReceived_lt: BigInt
    totalReceived_lte: BigInt
    totalReceived_not: BigInt
    totalReceived_not_in: [BigInt!]
    units: BigInt
    units_gt: BigInt
    units_gte: BigInt
    units_in: [BigInt!]
    units_lt: BigInt
    units_lte: BigInt
    units_not: BigInt
    units_not_in: [BigInt!]
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input SuperTokenCreated_filter {
    address: Bytes
    address_contains: Bytes
    address_in: [Bytes!]
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    symbol: String
    symbol_contains: String
    symbol_ends_with: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_ends_with: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_starts_with: String
    transaction: String
    transaction_contains: String
    transaction_ends_with: String
    transaction_gt: String
    transaction_gte: String
    transaction_in: [String!]
    transaction_lt: String
    transaction_lte: String
    transaction_not: String
    transaction_not_contains: String
    transaction_not_ends_with: String
    transaction_not_in: [String!]
    transaction_not_starts_with: String
    transaction_starts_with: String
    underlyingAddress: Bytes
    underlyingAddress_contains: Bytes
    underlyingAddress_in: [Bytes!]
    underlyingAddress_not: Bytes
    underlyingAddress_not_contains: Bytes
    underlyingAddress_not_in: [Bytes!]
}

input TokenDowngraded_filter {
    account: String
    account_contains: String
    account_ends_with: String
    account_gt: String
    account_gte: String
    account_in: [String!]
    account_lt: String
    account_lte: String
    account_not: String
    account_not_contains: String
    account_not_ends_with: String
    account_not_in: [String!]
    account_not_starts_with: String
    account_starts_with: String
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    token: String
    token_contains: String
    token_ends_with: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_ends_with: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_starts_with: String
    transaction: String
    transaction_contains: String
    transaction_ends_with: String
    transaction_gt: String
    transaction_gte: String
    transaction_in: [String!]
    transaction_lt: String
    transaction_lte: String
    transaction_not: String
    transaction_not_contains: String
    transaction_not_ends_with: String
    transaction_not_in: [String!]
    transaction_not_starts_with: String
    transaction_starts_with: String
}

input TokenTransfer_filter {
    from: String
    from_contains: String
    from_ends_with: String
    from_gt: String
    from_gte: String
    from_in: [String!]
    from_lt: String
    from_lte: String
    from_not: String
    from_not_contains: String
    from_not_ends_with: String
    from_not_in: [String!]
    from_not_starts_with: String
    from_starts_with: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    to: String
    to_contains: String
    to_ends_with: String
    to_gt: String
    to_gte: String
    to_in: [String!]
    to_lt: String
    to_lte: String
    to_not: String
    to_not_contains: String
    to_not_ends_with: String
    to_not_in: [String!]
    to_not_starts_with: String
    to_starts_with: String
    token: String
    token_contains: String
    token_ends_with: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_ends_with: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_starts_with: String
    transaction: String
    transaction_contains: String
    transaction_ends_with: String
    transaction_gt: String
    transaction_gte: String
    transaction_in: [String!]
    transaction_lt: String
    transaction_lte: String
    transaction_not: String
    transaction_not_contains: String
    transaction_not_ends_with: String
    transaction_not_in: [String!]
    transaction_not_starts_with: String
    transaction_starts_with: String
    value: BigInt
    value_gt: BigInt
    value_gte: BigInt
    value_in: [BigInt!]
    value_lt: BigInt
    value_lte: BigInt
    value_not: BigInt
    value_not_in: [BigInt!]
}

input TokenUpgraded_filter {
    account: String
    account_contains: String
    account_ends_with: String
    account_gt: String
    account_gte: String
    account_in: [String!]
    account_lt: String
    account_lte: String
    account_not: String
    account_not_contains: String
    account_not_ends_with: String
    account_not_in: [String!]
    account_not_starts_with: String
    account_starts_with: String
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    token: String
    token_contains: String
    token_ends_with: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_ends_with: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_starts_with: String
    transaction: String
    transaction_contains: String
    transaction_ends_with: String
    transaction_gt: String
    transaction_gte: String
    transaction_in: [String!]
    transaction_lt: String
    transaction_lte: String
    transaction_not: String
    transaction_not_contains: String
    transaction_not_ends_with: String
    transaction_not_in: [String!]
    transaction_not_starts_with: String
    transaction_starts_with: String
}

input Token_filter {
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    symbol: String
    symbol_contains: String
    symbol_ends_with: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_ends_with: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_starts_with: String
    underlyingAddress: Bytes
    underlyingAddress_contains: Bytes
    underlyingAddress_in: [Bytes!]
    underlyingAddress_not: Bytes
    underlyingAddress_not_contains: Bytes
    underlyingAddress_not_in: [Bytes!]
}

input Transaction_filter {
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
}

input indexSubscribed_filter {
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    index: String
    index_contains: String
    index_ends_with: String
    index_gt: String
    index_gte: String
    index_in: [String!]
    index_lt: String
    index_lte: String
    index_not: String
    index_not_contains: String
    index_not_ends_with: String
    index_not_in: [String!]
    index_not_starts_with: String
    index_starts_with: String
    subscriber: Bytes
    subscriber_contains: Bytes
    subscriber_in: [Bytes!]
    subscriber_not: Bytes
    subscriber_not_contains: Bytes
    subscriber_not_in: [Bytes!]
    transaction: String
    transaction_contains: String
    transaction_ends_with: String
    transaction_gt: String
    transaction_gte: String
    transaction_in: [String!]
    transaction_lt: String
    transaction_lte: String
    transaction_not: String
    transaction_not_contains: String
    transaction_not_ends_with: String
    transaction_not_in: [String!]
    transaction_not_starts_with: String
    transaction_starts_with: String
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input indexUnitUpdate_filter {
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    index: String
    index_contains: String
    index_ends_with: String
    index_gt: String
    index_gte: String
    index_in: [String!]
    index_lt: String
    index_lte: String
    index_not: String
    index_not_contains: String
    index_not_ends_with: String
    index_not_in: [String!]
    index_not_starts_with: String
    index_starts_with: String
    subscriber: Bytes
    subscriber_contains: Bytes
    subscriber_in: [Bytes!]
    subscriber_not: Bytes
    subscriber_not_contains: Bytes
    subscriber_not_in: [Bytes!]
    transaction: String
    transaction_contains: String
    transaction_ends_with: String
    transaction_gt: String
    transaction_gte: String
    transaction_in: [String!]
    transaction_lt: String
    transaction_lte: String
    transaction_not: String
    transaction_not_contains: String
    transaction_not_ends_with: String
    transaction_not_in: [String!]
    transaction_not_starts_with: String
    transaction_starts_with: String
    units: BigInt
    units_gt: BigInt
    units_gte: BigInt
    units_in: [BigInt!]
    units_lt: BigInt
    units_lte: BigInt
    units_not: BigInt
    units_not_in: [BigInt!]
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input indexUnsubscribed_filter {
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    index: String
    index_contains: String
    index_ends_with: String
    index_gt: String
    index_gte: String
    index_in: [String!]
    index_lt: String
    index_lte: String
    index_not: String
    index_not_contains: String
    index_not_ends_with: String
    index_not_in: [String!]
    index_not_starts_with: String
    index_starts_with: String
    subscriber: Bytes
    subscriber_contains: Bytes
    subscriber_in: [Bytes!]
    subscriber_not: Bytes
    subscriber_not_contains: Bytes
    subscriber_not_in: [Bytes!]
    transaction: String
    transaction_contains: String
    transaction_ends_with: String
    transaction_gt: String
    transaction_gte: String
    transaction_in: [String!]
    transaction_lt: String
    transaction_lte: String
    transaction_not: String
    transaction_not_contains: String
    transaction_not_ends_with: String
    transaction_not_in: [String!]
    transaction_not_starts_with: String
    transaction_starts_with: String
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input indexUpdate_filter {
    distribution: BigInt
    distribution_gt: BigInt
    distribution_gte: BigInt
    distribution_in: [BigInt!]
    distribution_lt: BigInt
    distribution_lte: BigInt
    distribution_not: BigInt
    distribution_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    index: String
    index_contains: String
    index_ends_with: String
    index_gt: String
    index_gte: String
    index_in: [String!]
    index_lt: String
    index_lte: String
    index_not: String
    index_not_contains: String
    index_not_ends_with: String
    index_not_in: [String!]
    index_not_starts_with: String
    index_starts_with: String
    newIndexValue: BigInt
    newIndexValue_gt: BigInt
    newIndexValue_gte: BigInt
    newIndexValue_in: [BigInt!]
    newIndexValue_lt: BigInt
    newIndexValue_lte: BigInt
    newIndexValue_not: BigInt
    newIndexValue_not_in: [BigInt!]
    oldIndexValue: BigInt
    oldIndexValue_gt: BigInt
    oldIndexValue_gte: BigInt
    oldIndexValue_in: [BigInt!]
    oldIndexValue_lt: BigInt
    oldIndexValue_lte: BigInt
    oldIndexValue_not: BigInt
    oldIndexValue_not_in: [BigInt!]
    totalUnitsApproved: BigInt
    totalUnitsApproved_gt: BigInt
    totalUnitsApproved_gte: BigInt
    totalUnitsApproved_in: [BigInt!]
    totalUnitsApproved_lt: BigInt
    totalUnitsApproved_lte: BigInt
    totalUnitsApproved_not: BigInt
    totalUnitsApproved_not_in: [BigInt!]
    totalUnitsPending: BigInt
    totalUnitsPending_gt: BigInt
    totalUnitsPending_gte: BigInt
    totalUnitsPending_in: [BigInt!]
    totalUnitsPending_lt: BigInt
    totalUnitsPending_lte: BigInt
    totalUnitsPending_not: BigInt
    totalUnitsPending_not_in: [BigInt!]
    transaction: String
    transaction_contains: String
    transaction_ends_with: String
    transaction_gt: String
    transaction_gte: String
    transaction_in: [String!]
    transaction_lt: String
    transaction_lte: String
    transaction_not: String
    transaction_not_contains: String
    transaction_not_ends_with: String
    transaction_not_in: [String!]
    transaction_not_starts_with: String
    transaction_starts_with: String
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input subscriptionApproved_filter {
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    subscriber: String
    subscriber_contains: String
    subscriber_ends_with: String
    subscriber_gt: String
    subscriber_gte: String
    subscriber_in: [String!]
    subscriber_lt: String
    subscriber_lte: String
    subscriber_not: String
    subscriber_not_contains: String
    subscriber_not_ends_with: String
    subscriber_not_in: [String!]
    subscriber_not_starts_with: String
    subscriber_starts_with: String
    transaction: String
    transaction_contains: String
    transaction_ends_with: String
    transaction_gt: String
    transaction_gte: String
    transaction_in: [String!]
    transaction_lt: String
    transaction_lte: String
    transaction_not: String
    transaction_not_contains: String
    transaction_not_ends_with: String
    transaction_not_in: [String!]
    transaction_not_starts_with: String
    transaction_starts_with: String
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input subscriptionRevoked_filter {
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    subscriber: String
    subscriber_contains: String
    subscriber_ends_with: String
    subscriber_gt: String
    subscriber_gte: String
    subscriber_in: [String!]
    subscriber_lt: String
    subscriber_lte: String
    subscriber_not: String
    subscriber_not_contains: String
    subscriber_not_ends_with: String
    subscriber_not_in: [String!]
    subscriber_not_starts_with: String
    subscriber_starts_with: String
    transaction: String
    transaction_contains: String
    transaction_ends_with: String
    transaction_gt: String
    transaction_gte: String
    transaction_in: [String!]
    transaction_lt: String
    transaction_lte: String
    transaction_not: String
    transaction_not_contains: String
    transaction_not_ends_with: String
    transaction_not_in: [String!]
    transaction_not_starts_with: String
    transaction_starts_with: String
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input subscriptionUnitsUpdated_filter {
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    subscriber: String
    subscriber_contains: String
    subscriber_ends_with: String
    subscriber_gt: String
    subscriber_gte: String
    subscriber_in: [String!]
    subscriber_lt: String
    subscriber_lte: String
    subscriber_not: String
    subscriber_not_contains: String
    subscriber_not_ends_with: String
    subscriber_not_in: [String!]
    subscriber_not_starts_with: String
    subscriber_starts_with: String
    transaction: String
    transaction_contains: String
    transaction_ends_with: String
    transaction_gt: String
    transaction_gte: String
    transaction_in: [String!]
    transaction_lt: String
    transaction_lte: String
    transaction_not: String
    transaction_not_contains: String
    transaction_not_ends_with: String
    transaction_not_in: [String!]
    transaction_not_starts_with: String
    transaction_starts_with: String
    units: BigInt
    units_gt: BigInt
    units_gte: BigInt
    units_in: [BigInt!]
    units_lt: BigInt
    units_lte: BigInt
    units_not: BigInt
    units_not_in: [BigInt!]
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}


scalar BigDecimal

scalar BigInt

scalar Bytes
